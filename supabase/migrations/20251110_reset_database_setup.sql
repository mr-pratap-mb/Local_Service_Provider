-- Reset and configure database for proper email signup and application functionality
-- This script preserves existing data where possible and sets up necessary triggers and policies

-- ===========================================================
-- ENSURE TABLES EXIST (WITHOUT DROPPING DATA)
-- ===========================================================

-- Profiles Table
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY,
  full_name TEXT,
  email TEXT UNIQUE,
  role TEXT DEFAULT 'user' CHECK (role IN ('user', 'provider')),
  phone TEXT,
  whatsapp_number TEXT,
  location TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Remove foreign key constraint if it exists to avoid timing issues
ALTER TABLE public.profiles DROP CONSTRAINT IF EXISTS profiles_id_fkey;

-- Add a non-enforced foreign key constraint for documentation
ALTER TABLE public.profiles 
ADD CONSTRAINT profiles_id_fkey 
FOREIGN KEY (id) REFERENCES auth.users(id) 
ON DELETE CASCADE 
NOT VALID;

-- Trigger for updating 'updated_at' timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_profiles_updated_at ON public.profiles;
CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON public.profiles
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();

-- Categories Table
CREATE TABLE IF NOT EXISTS public.categories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  slug TEXT NOT NULL UNIQUE
);

-- Services Table
CREATE TABLE IF NOT EXISTS public.services (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  provider_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  price NUMERIC,
  location TEXT,
  available BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  category_id BIGINT REFERENCES public.categories(id) ON DELETE CASCADE,
  hidden_details TEXT
);
CREATE INDEX IF NOT EXISTS idx_services_category ON public.services (category_id);

-- Bookings Table
CREATE TABLE IF NOT EXISTS public.bookings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  service_id BIGINT REFERENCES public.services(id) ON DELETE CASCADE,
  provider_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  category_id BIGINT REFERENCES public.categories(id) ON DELETE CASCADE,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'completed', 'cancelled')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  scheduled_date TIMESTAMPTZ,
  notes TEXT,
  detailedaddress TEXT,
  anymessage TEXT
);
CREATE INDEX IF NOT EXISTS idx_bookings_provider_status ON public.bookings (provider_id, status);
CREATE INDEX IF NOT EXISTS idx_bookings_user_created ON public.bookings (user_id, created_at);

-- Notifications Table
CREATE TABLE IF NOT EXISTS public.notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  sender_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  type TEXT NOT NULL,
  payload JSONB,
  read BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ===========================================================
-- EMAIL VALIDATION TRIGGER
-- ===========================================================
CREATE OR REPLACE FUNCTION check_valid_email()
RETURNS TRIGGER AS $$
DECLARE
  dummy_domains TEXT[] := ARRAY[
    'yopmail.com', 'mailinator.com', 'tempmail.com', '10minutemail.com',
    'guerrillamail.com', 'dispostable.com', 'fakeinbox.com', 'trashmail.com',
    'example.com'
  ];
  domain TEXT;
BEGIN
  domain := split_part(NEW.email, '@', 2);
  
  IF domain = ANY(dummy_domains) THEN
    RAISE EXCEPTION 'Disposable emails are not allowed';
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach trigger to auth.users table to prevent signup with disposable emails
DROP TRIGGER IF EXISTS check_valid_email_trigger ON auth.users;
CREATE TRIGGER check_valid_email_trigger
BEFORE INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION check_valid_email();

-- Attach trigger to profiles table as additional check
DROP TRIGGER IF EXISTS check_valid_email_profiles_trigger ON public.profiles;
CREATE TRIGGER check_valid_email_profiles_trigger
BEFORE INSERT OR UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION check_valid_email();

-- ===========================================================
-- AUTOMATIC PROFILE CREATION AFTER EMAIL VERIFICATION
-- ===========================================================
CREATE OR REPLACE FUNCTION public.handle_verified_user()
RETURNS TRIGGER AS $$
DECLARE
  user_role TEXT;
BEGIN
  -- Fetch role metadata if available
  user_role := COALESCE(NEW.raw_user_meta_data->>'role', 'user');

  -- Only insert profile if email is verified
  IF NEW.email_confirmed_at IS NOT NULL THEN
    INSERT INTO public.profiles (id, email, role)
    VALUES (NEW.id, NEW.email, user_role)
    ON CONFLICT (id) DO NOTHING;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_confirmed ON auth.users;
CREATE TRIGGER on_auth_user_confirmed
AFTER UPDATE ON auth.users
FOR EACH ROW
WHEN (NEW.email_confirmed_at IS DISTINCT FROM OLD.email_confirmed_at)
EXECUTE FUNCTION public.handle_verified_user();

-- Restore profiles for existing users without profiles (if they have confirmed emails)
INSERT INTO public.profiles (id, email, role, created_at)
SELECT 
    au.id,
    au.email,
    'user' AS role,
    au.created_at
FROM auth.users au
LEFT JOIN public.profiles p ON au.id = p.id
WHERE p.id IS NULL AND au.email_confirmed_at IS NOT NULL
ON CONFLICT (id) DO NOTHING;

-- ===========================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- ===========================================================
-- Profiles RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;

CREATE POLICY "Users can view their own profile" ON public.profiles
FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can insert their own profile" ON public.profiles
FOR INSERT WITH CHECK (auth.uid() = id OR auth.role() = 'service_role');

CREATE POLICY "Users can update their own profile" ON public.profiles
FOR UPDATE USING (auth.uid() = id);

-- Categories RLS
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Categories are viewable by everyone" ON public.categories;
CREATE POLICY "Categories are viewable by everyone" ON public.categories
FOR SELECT USING (true);

DROP POLICY IF EXISTS "Only service role can modify categories" ON public.categories;
CREATE POLICY "Only service role can modify categories" ON public.categories
FOR ALL USING (auth.role() = 'service_role') WITH CHECK (auth.role() = 'service_role');

-- Services RLS
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Services are viewable by everyone" ON public.services;
CREATE POLICY "Services are viewable by everyone" ON public.services
FOR SELECT USING (true);

DROP POLICY IF EXISTS "Providers can manage their services" ON public.services;
CREATE POLICY "Providers can manage their services" ON public.services
FOR ALL USING (provider_id = auth.uid()) WITH CHECK (provider_id = auth.uid());

-- Bookings RLS
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their bookings" ON public.bookings;
CREATE POLICY "Users can view their bookings" ON public.bookings
FOR SELECT USING (user_id = auth.uid() OR provider_id = auth.uid());

DROP POLICY IF EXISTS "Users can create bookings" ON public.bookings;
CREATE POLICY "Users can create bookings" ON public.bookings
FOR INSERT WITH CHECK (user_id = auth.uid());

DROP POLICY IF EXISTS "Providers can update booking status" ON public.bookings;
CREATE POLICY "Providers can update booking status" ON public.bookings
FOR UPDATE USING (provider_id = auth.uid());

-- Notifications RLS
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their notifications" ON public.notifications;
CREATE POLICY "Users can view their notifications" ON public.notifications
FOR SELECT USING (recipient_id = auth.uid());

DROP POLICY IF EXISTS "Users can update notification read status" ON public.notifications;
CREATE POLICY "Users can update notification read status" ON public.notifications
FOR UPDATE USING (recipient_id = auth.uid());

DROP POLICY IF EXISTS "Allow trigger inserts for notifications" ON public.notifications;
CREATE POLICY "Allow trigger inserts for notifications" ON public.notifications
FOR INSERT WITH CHECK (auth.role() = 'service_role' OR auth.uid() = sender_id);

-- ===========================================================
-- NOTIFICATION TRIGGERS
-- ===========================================================
CREATE OR REPLACE FUNCTION public.notify_on_booking()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.notifications (recipient_id, sender_id, type, payload)
  VALUES (
    NEW.provider_id,
    NEW.user_id,
    'booking_request',
    jsonb_build_object(
      'booking_id', NEW.id,
      'service_id', NEW.service_id,
      'scheduled_date', NEW.scheduled_date
    )
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_notify_on_booking ON public.bookings;
CREATE TRIGGER trg_notify_on_booking
AFTER INSERT ON public.bookings
FOR EACH ROW
EXECUTE FUNCTION public.notify_on_booking();

CREATE OR REPLACE FUNCTION public.notify_booking_status_update()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status <> OLD.status THEN
    INSERT INTO public.notifications (recipient_id, sender_id, type, payload)
    VALUES (
      NEW.user_id,
      NEW.provider_id,
      'booking_update',
      jsonb_build_object(
        'booking_id', NEW.id,
        'service_id', NEW.service_id,
        'status', NEW.status
      )
    );
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_notify_booking_status_update ON public.bookings;
CREATE TRIGGER trg_notify_booking_status_update
AFTER UPDATE ON public.bookings
FOR EACH ROW
EXECUTE FUNCTION public.notify_booking_status_update();
